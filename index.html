<!doctype html>
<html lang="el">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Î‘Î½Î±Ï†Î¿ÏÎ¬ (Î±ÏÎ¹ÏƒÏ„ÎµÏÎ¬) + Î£Î·Î¼ÎµÎ¹ÏÏƒÎµÎ¹Ï‚ (Î´ÎµÎ¾Î¹Î¬) â€” ÎºÎ¿Î¹Î½ÏŒ scroll</title>
  <style>
    :root{
      --bg:#0b1220;
      --panel:#0f1a33;
      --panel2:#0c152b;
      --text:#e8eefc;
      --muted:#9fb2e8;
      --line:rgba(255,255,255,.08);
      --accent:#7aa2ff;
      --good:#45d483;
      --warn:#ffce5c;
      --bad:#ff6b6b;
      --shadow: 0 10px 30px rgba(0,0,0,.35);
      --radius:18px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background: radial-gradient(1200px 900px at 20% 10%, rgba(122,162,255,.18), transparent 60%),
                  radial-gradient(900px 900px at 80% 0%, rgba(69,212,131,.12), transparent 60%),
                  radial-gradient(900px 900px at 50% 100%, rgba(255,206,92,.10), transparent 55%),
                  var(--bg);
      color:var(--text);
      overflow-x:hidden;
    }

    .topbar{
      position: sticky; top:0; z-index: 50;
      backdrop-filter: blur(10px);
      background: linear-gradient(180deg, rgba(11,18,32,.92), rgba(11,18,32,.72));
      border-bottom: 1px solid var(--line);
    }
    .topbar-inner{
      max-width: 1400px;
      margin:0 auto;
      padding: 14px 14px;
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap: wrap;
    }
    .brand{
      display:flex; align-items:baseline; gap:10px;
      margin-right:auto;
    }
    .brand h1{
      font-size: 16px;
      margin:0;
      letter-spacing:.2px;
      font-weight: 750;
    }
    .brand .sub{
      color:var(--muted);
      font-size: 12px;
    }

    .btn, .btn2{
      appearance:none;
      border: 1px solid var(--line);
      border-radius: 14px;
      padding: 10px 12px;
      background: rgba(15,26,51,.65);
      color: var(--text);
      cursor:pointer;
      box-shadow: var(--shadow);
      display:inline-flex;
      gap:8px;
      align-items:center;
      font-weight: 650;
      letter-spacing: .2px;
      user-select:none;
    }
    .btn:hover{border-color: rgba(122,162,255,.35)}
    .btn:active{transform: translateY(1px)}
    .btn2{
      background: rgba(12,21,43,.65);
      box-shadow: none;
      padding: 10px 10px;
      font-weight: 600;
    }

    .pill{
      font-family: var(--mono);
      font-size: 12px;
      color: var(--muted);
      padding: 8px 10px;
      border: 1px solid var(--line);
      border-radius: 999px;
      background: rgba(12,21,43,.55);
    }

    .search{
      display:flex;
      align-items:center;
      gap:8px;
      border: 1px solid var(--line);
      border-radius: 14px;
      background: rgba(12,21,43,.55);
      padding: 8px 10px;
      min-width: 240px;
    }
    .search input{
      background: transparent;
      border: 0;
      outline: 0;
      color: var(--text);
      width: 100%;
      font-size: 13px;
    }
    .search input::placeholder{color: rgba(159,178,232,.7)}

    .wrap{
      max-width: 1400px;
      margin: 0 auto;
      padding: 16px 14px 24px;
    }

    .hint{
      margin: 10px 0 16px;
      padding: 12px 14px;
      border-radius: var(--radius);
      border: 1px dashed rgba(122,162,255,.35);
      background: rgba(15,26,51,.35);
      color: var(--muted);
      line-height: 1.35;
    }
    .hint b{color: var(--text)}

    .gridHead{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
      align-items:end;
      margin-top: 10px;
    }
    .colTitle{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 10px;
      padding: 10px 12px;
      border-radius: 14px;
      border: 1px solid var(--line);
      background: rgba(12,21,43,.55);
    }
    .colTitle .t{
      font-weight: 750;
      font-size: 13px;
      letter-spacing:.2px;
    }
    .colTitle .small{
      color: var(--muted);
      font-size: 12px;
      font-family: var(--mono);
    }

    .rows{
      margin-top: 10px;
      display:grid;
      grid-template-columns: 1fr;
      gap: 12px;
    }

    .row{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
      align-items:start;
    }

    .card{
      border-radius: var(--radius);
      border: 1px solid var(--line);
      background: rgba(15,26,51,.45);
      box-shadow: var(--shadow);
      overflow:hidden;
      position: relative;
    }
    .card .meta{
      display:flex;
      justify-content:space-between;
      align-items:center;
      padding: 10px 12px;
      border-bottom: 1px solid var(--line);
      background: rgba(12,21,43,.55);
      gap: 10px;
    }
    .card .meta .idx{
      font-family: var(--mono);
      font-size: 12px;
      color: var(--muted);
    }
    .card .meta .tags{
      display:flex; gap: 8px; align-items:center;
    }
    .tag{
      font-family: var(--mono);
      font-size: 11px;
      padding: 4px 8px;
      border-radius: 999px;
      border: 1px solid var(--line);
      background: rgba(15,26,51,.55);
      color: var(--muted);
    }

    .ref{
      padding: 12px 14px 14px;
      color: var(--text);
      line-height: 1.45;
      overflow-wrap: anywhere;
    }
    .ref img{max-width:100%; height:auto; border-radius: 12px; border: 1px solid var(--line)}
    .ref table{max-width:100%; border-collapse: collapse}
    .ref td, .ref th{border: 1px solid rgba(255,255,255,.10); padding: 6px 8px}
    .ref a{color: var(--accent)}
    .ref pre, .ref code{
      font-family: var(--mono);
      background: rgba(0,0,0,.25);
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 12px;
      padding: 10px;
      overflow:auto;
    }

    .noteBox{
      padding: 0;
    }
    textarea.note{
      width:100%;
      min-height: 120px;
      border: 0;
      outline: 0;
      resize: vertical;
      padding: 12px 14px 14px;
      background: transparent;
      color: var(--text);
      line-height: 1.5;
      font-size: 14px;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }
    textarea.note::placeholder{color: rgba(159,178,232,.65)}
    .noteFooter{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap: 10px;
      padding: 10px 12px;
      border-top: 1px solid var(--line);
      background: rgba(12,21,43,.55);
      color: var(--muted);
      font-family: var(--mono);
      font-size: 12px;
    }

    .toast{
      position: fixed;
      right: 14px;
      bottom: 14px;
      z-index: 99;
      padding: 10px 12px;
      border-radius: 14px;
      border: 1px solid var(--line);
      background: rgba(12,21,43,.85);
      box-shadow: var(--shadow);
      color: var(--muted);
      font-family: var(--mono);
      font-size: 12px;
      opacity: 0;
      transform: translateY(8px);
      transition: opacity .2s ease, transform .2s ease;
      pointer-events:none;
    }
    .toast.show{opacity:1; transform: translateY(0)}

    .hidden{display:none !important}

    @media (max-width: 980px){
      .gridHead{grid-template-columns: 1fr}
      .row{grid-template-columns: 1fr}
    }
  </style>
</head>
<body>
  <div class="topbar">
    <div class="topbar-inner">
      <div class="brand">
        <h1>Î‘Î½Î±Ï†Î¿ÏÎ¬ â†” Î£Î·Î¼ÎµÎ¹ÏÏƒÎµÎ¹Ï‚</h1>
        <div class="sub">Î­Î½Î± scroll Â· Î´Î¯Ï€Î»Î± Î´Î¯Ï€Î»Î± Â· autosave</div>
      </div>

      <label class="btn" title="Î”Î¹Î¬Î»ÎµÎ¾Îµ Ï„Î¿Î½ Ï†Î¬ÎºÎµÎ»Î¿ Ï€Î¿Ï… Î­ÏƒÏ‰ÏƒÎµÏ‚ Î¼Îµ Ctrl+S â†’ Webpage, Complete">
        ğŸ“ Upload Folder
        <input id="folder" type="file" webkitdirectory multiple class="hidden" />
      </label>

      <select id="htmlPick" class="btn2 hidden" title="Î‘Î½ Î²ÏÎ­Î¸Î·ÎºÎ±Î½ Ï€Î¿Î»Î»Î¬ .html, Î´Î¹Î¬Î»ÎµÎ¾Îµ">
      </select>

      <div class="search" title="Î¦Î¯Î»Ï„ÏÎ¿ ÏƒÎµ blocks (ÎºÎµÎ¯Î¼ÎµÎ½Î¿ Î±Î½Î±Ï†Î¿ÏÎ¬Ï‚ + ÏƒÎ·Î¼ÎµÎ¹ÏÏƒÎµÎ¹Ï‚)">
        ğŸ” <input id="q" type="text" placeholder="ÏˆÎ¬Î¾Îµ ÎºÎ¬Ï„Î¹â€¦" />
      </div>

      <button id="toggleHeights" class="btn2" title="ÎšÎ»ÎµÎ¹Î´ÏÎ½ÎµÎ¹ ÏÏˆÎ·: Î· Î´ÎµÎ¾Î¹Î¬ ÏƒÎ·Î¼ÎµÎ¯Ï‰ÏƒÎ· Ï€Î±Î¯ÏÎ½ÎµÎ¹ Ï„Î¿Ï…Î»Î¬Ï‡Î¹ÏƒÏ„Î¿Î½ Ï„Î¿ ÏÏˆÎ¿Ï‚ Ï„Î¿Ï… Î±ÏÎ¹ÏƒÏ„ÎµÏÎ¿Ï block">
        ğŸ§· lock heights: <span id="lockState">OFF</span>
      </button>

      <button id="exportHtml" class="btn" title="ÎšÎ±Ï„ÎµÎ²Î¬Î¶ÎµÎ¹ HTML Î¼Îµ Î±Î½Î±Ï†Î¿ÏÎ¬+ÏƒÎ·Î¼ÎµÎ¹ÏÏƒÎµÎ¹Ï‚ (ÎºÎ±Î¹ Î´Î¹Î±Ï„Î·ÏÎµÎ¯ Ï„Î¿ layout)">
        â¬‡ï¸ Export HTML
      </button>

      <button id="exportJson" class="btn2" title="ÎšÎ±Ï„ÎµÎ²Î¬Î¶ÎµÎ¹ Î¼ÏŒÎ½Î¿ Ï„Î¹Ï‚ ÏƒÎ·Î¼ÎµÎ¹ÏÏƒÎµÎ¹Ï‚ ÏƒÎµ JSON (backup)">
        ğŸ’¾ Export Notes JSON
      </button>

      <label class="btn2" title="Î•Ï€Î±Î½Î±Ï†Î¿ÏÎ¬ ÏƒÎ·Î¼ÎµÎ¹ÏÏƒÎµÏ‰Î½ Î±Ï€ÏŒ JSON">
        â™»ï¸ Import Notes JSON
        <input id="importJson" type="file" accept="application/json" class="hidden" />
      </label>

      <span id="status" class="pill">ÎºÎ±Î½Î­Î½Î± Î±ÏÏ‡ÎµÎ¯Î¿</span>
    </div>
  </div>

  <div class="wrap">
    <div class="hint">
      <b>Î§ÏÎ®ÏƒÎ· Ï‡Ï‰ÏÎ¯Ï‚ Î´ÏÎ¬Î¼Î±Ï„Î±:</b> Î Î®Î³Î±Î¹Î½Îµ ÏƒÏ„Î· ÏƒÎµÎ»Î¯Î´Î± Î±Î½Î±Ï†Î¿ÏÎ¬Ï‚ â†’ <b>Ctrl+S</b> â†’ <b>Webpage, Complete</b>.
      Î˜Î± Ï€Î¬ÏÎµÎ¹Ï‚ Î­Î½Î± <b>.html</b> + Î­Î½Î±Î½ Ï†Î¬ÎºÎµÎ»Î¿ Î¼Îµ ÎµÎ¹ÎºÏŒÎ½ÎµÏ‚/CSS. ÎœÎµÏ„Î¬ ÎµÎ´Ï: <b>Upload Folder</b> ÎºÎ±Î¹ Î´Î¹Î¬Î»ÎµÎ¾Îµ
      Ï„Î¿Î½ Ï†Î¬ÎºÎµÎ»Î¿ Ï€Î¿Ï… Ï€ÎµÏÎ¹Î­Ï‡ÎµÎ¹ Î±Ï…Ï„Î¬ Ï„Î± Î±ÏÏ‡ÎµÎ¯Î±. ÎŸÎ¹ ÎµÎ¹ÎºÏŒÎ½ÎµÏ‚ Î¸Î± ÎµÎ¼Ï†Î±Î½Î¹ÏƒÏ„Î¿ÏÎ½ ÎºÎ±Î½Î¿Î½Î¹ÎºÎ¬.
    </div>

    <div class="gridHead hidden" id="gridHead">
      <div class="colTitle">
        <div class="t">Î‘ÏÎ¹ÏƒÏ„ÎµÏÎ¬: Î±Î½Î±Ï†Î¿ÏÎ¬ (block)</div>
        <div class="small" id="refInfo"></div>
      </div>
      <div class="colTitle">
        <div class="t">Î”ÎµÎ¾Î¹Î¬: ÏƒÎ·Î¼ÎµÎ¯Ï‰ÏƒÎ· (Î±Î½Î¬ block)</div>
        <div class="small">autosave: localStorage</div>
      </div>
    </div>

    <div class="rows" id="rows"></div>
  </div>

  <div class="toast" id="toast"></div>

<script>
(() => {
  const elFolder = document.getElementById('folder');
  const elPick = document.getElementById('htmlPick');
  const elRows = document.getElementById('rows');
  const elStatus = document.getElementById('status');
  const elGridHead = document.getElementById('gridHead');
  const elRefInfo = document.getElementById('refInfo');
  const elQ = document.getElementById('q');
  const btnExportHtml = document.getElementById('exportHtml');
  const btnExportJson = document.getElementById('exportJson');
  const elImportJson = document.getElementById('importJson');
  const btnToggleHeights = document.getElementById('toggleHeights');
  const elLockState = document.getElementById('lockState');
  const toast = document.getElementById('toast');

  let assetMap = new Map(); // key: relative path (decode, no leading ./) -> blobURL
  let sKey = null; // storage namespace key for this source
  let blocks = []; // {html, type, plain}
  let lockHeights = false;

  const showToast = (msg) => {
    toast.textContent = msg;
    toast.classList.add('show');
    setTimeout(() => toast.classList.remove('show'), 1200);
  };

  const normalizePath = (p) => {
    if (!p) return '';
    p = p.replace(/^\.\/+/, '');
    try { p = decodeURIComponent(p); } catch {}
    return p;
  };

  const isRelative = (url) => {
    if (!url) return false;
    const u = url.trim();
    if (/^(data:|blob:|https?:|mailto:|tel:|javascript:)/i.test(u)) return false;
    if (/^\/\//.test(u)) return false;
    return true;
  };

  const sha256 = async (text) => {
    const enc = new TextEncoder().encode(text);
    const hash = await crypto.subtle.digest('SHA-256', enc);
    return [...new Uint8Array(hash)].map(b => b.toString(16).padStart(2,'0')).join('');
  };

  const safeClean = (doc) => {
    // remove risky / irrelevant nodes
    doc.querySelectorAll('script, iframe, object, embed, form, input, button, textarea, select, noscript').forEach(n => n.remove());
    // remove inline event handlers
    doc.querySelectorAll('*').forEach(n => {
      [...n.attributes].forEach(a => {
        if (/^on/i.test(a.name)) n.removeAttribute(a.name);
      });
    });
  };

  const rewriteCssUrls = (cssText) => {
    // Replace url(...) relative refs using assetMap
    return cssText.replace(/url\(([^)]+)\)/gi, (m, inside) => {
      let raw = inside.trim().replace(/^['"]|['"]$/g, '');
      if (!isRelative(raw)) return m;
      raw = normalizePath(raw.split('#')[0].split('?')[0]);
      const mapped = assetMap.get(raw);
      if (!mapped) return m;
      return `url("${mapped}")`;
    });
  };

  const rewriteDomAssets = async (doc, rootPrefix) => {
    // rootPrefix: folder root name like "MySavedPage/" or "".
    const mapLookup = (path) => {
      path = normalizePath(path);
      // Try direct
      if (assetMap.has(path)) return assetMap.get(path);
      // Try prefixed (if the html uses foldername/file and the uploaded relative paths include rootPrefix)
      if (rootPrefix && assetMap.has(normalizePath(rootPrefix + path))) return assetMap.get(normalizePath(rootPrefix + path));
      return null;
    };

    // <img src>
    doc.querySelectorAll('img[src]').forEach(img => {
      const src = img.getAttribute('src') || '';
      if (!isRelative(src)) return;
      const clean = normalizePath(src.split('#')[0].split('?')[0]);
      const mapped = mapLookup(clean);
      if (mapped) img.setAttribute('src', mapped);
    });

    // <a href> (optional)
    doc.querySelectorAll('a[href]').forEach(a => {
      const href = a.getAttribute('href') || '';
      if (!isRelative(href)) return;
      const clean = normalizePath(href);
      const mapped = mapLookup(clean.split('#')[0].split('?')[0]);
      if (mapped) a.setAttribute('href', mapped);
    });

    // inline styles with url(...)
    doc.querySelectorAll('[style]').forEach(n => {
      const st = n.getAttribute('style');
      if (!st || !/url\(/i.test(st)) return;
      n.setAttribute('style', rewriteCssUrls(st));
    });

    // <link rel="stylesheet" href="...">
    const links = [...doc.querySelectorAll('link[rel="stylesheet"][href]')];
    for (const link of links) {
      const href = link.getAttribute('href') || '';
      if (!isRelative(href)) continue;
      const clean = normalizePath(href.split('#')[0].split('?')[0]);
      const mapped = mapLookup(clean);
      if (!mapped) continue;

      // Read original css file from uploads (we only have blob URL, not the File)
      // We'll rebuild CSS by finding the File via assetMapReverse.
      // So we keep a reverse map too.
      const cssFile = assetMapReverse.get(mapped);
      if (cssFile) {
        try {
          const text = await cssFile.text();
          const fixed = rewriteCssUrls(text);
          const blobUrl = URL.createObjectURL(new Blob([fixed], {type:'text/css'}));
          link.setAttribute('href', blobUrl);
          // Remember to avoid leaking: no revoke here because we want it alive
        } catch {
          link.setAttribute('href', mapped);
        }
      } else {
        link.setAttribute('href', mapped);
      }
    }
  };

  const assetMapReverse = new Map(); // blobURL -> File

  const pickHtmlCandidates = (files) => {
    const htmlFiles = files.filter(f => /\.html?$/i.test(f.name));
    // Prefer the biggest html file (usually the main page)
    htmlFiles.sort((a,b) => (b.size - a.size));
    return htmlFiles;
  };

  const bestBody = (doc) => {
    // Try a few common containers; else fallback to body.
    const cand = [
      doc.querySelector('main'),
      doc.querySelector('#content'),
      doc.querySelector('#main'),
      doc.querySelector('.content'),
      doc.querySelector('.main'),
      doc.body
    ].filter(Boolean)[0];
    return cand || doc.body;
  };

  const flattenToBlocks = (container) => {
    const out = [];
    const nodes = [...container.childNodes].filter(n => {
      if (n.nodeType === Node.TEXT_NODE) return n.textContent.trim().length > 0;
      if (n.nodeType !== Node.ELEMENT_NODE) return false;
      const tag = n.tagName.toLowerCase();
      // skip layout junk sometimes
      if (tag === 'header' || tag === 'footer' || tag === 'nav') return false;
      return true;
    });

    const pushNode = (node) => {
      if (node.nodeType === Node.TEXT_NODE) {
        const t = node.textContent.trim();
        if (!t) return;
        out.push({ html: `<p>${escapeHtml(t)}</p>`, type: 'text', plain: t });
        return;
      }

      const tag = node.tagName.toLowerCase();
      if (tag === 'ul' || tag === 'ol') {
        const lis = [...node.querySelectorAll(':scope > li')];
        if (lis.length && lis.length <= 30) {
          lis.forEach(li => {
            const h = `<div>${li.outerHTML}</div>`;
            out.push({ html: h, type: 'li', plain: li.textContent.trim() });
          });
        } else {
          out.push({ html: node.outerHTML, type: tag, plain: node.textContent.trim() });
        }
        return;
      }

      if (/^h[1-6]$/.test(tag) || tag === 'p' || tag === 'pre' || tag === 'blockquote' || tag === 'table' || tag === 'img') {
        out.push({ html: node.outerHTML, type: tag, plain: node.textContent.trim() });
        return;
      }

      // For div/section/article: if it contains block-level children, split them
      if (tag === 'div' || tag === 'section' || tag === 'article') {
        const kids = [...node.children].filter(e => {
          const t = e.tagName.toLowerCase();
          return ['h1','h2','h3','h4','h5','h6','p','ul','ol','pre','blockquote','table','img'].includes(t);
        });
        if (kids.length) {
          kids.forEach(k => pushNode(k));
          return;
        }
      }

      // fallback: keep outerHTML if meaningful
      const plain = node.textContent.trim();
      if (plain.length > 0) out.push({ html: node.outerHTML, type: tag, plain });
    };

    nodes.forEach(pushNode);

    // if too few blocks, try deeper: body all common tags
    if (out.length < 6) {
      const deep = [...container.querySelectorAll('h1,h2,h3,h4,h5,h6,p,li,pre,blockquote,table,img')]
        .slice(0, 3000)
        .map(n => ({ html: n.outerHTML, type: n.tagName.toLowerCase(), plain: n.textContent.trim() }));
      return deep.length ? deep : out;
    }

    return out.slice(0, 3000);
  };

  const escapeHtml = (s) => s
    .replaceAll('&', '&amp;')
    .replaceAll('<', '&lt;')
    .replaceAll('>', '&gt;')
    .replaceAll('"', '&quot;')
    .replaceAll("'", '&#039;');

  const bytesToNice = (n) => {
    if (n < 1024) return `${n}B`;
    if (n < 1024*1024) return `${(n/1024).toFixed(1)}KB`;
    return `${(n/1024/1024).toFixed(1)}MB`;
  };

  const makeRow = (i, block) => {
    const row = document.createElement('div');
    row.className = 'row';
    row.dataset.idx = String(i);

    const left = document.createElement('div');
    left.className = 'card';
    left.innerHTML = `
      <div class="meta">
        <div class="idx">#${i+1}</div>
        <div class="tags">
          <span class="tag">${block.type}</span>
          <span class="tag">${block.plain ? (block.plain.length > 30 ? block.plain.slice(0,30)+'â€¦' : block.plain) : ''}</span>
        </div>
      </div>
      <div class="ref"></div>
    `;
    left.querySelector('.ref').innerHTML = block.html;

    const right = document.createElement('div');
    right.className = 'card noteBox';
    const noteKey = `${sKey}:note:${i}`;
    const saved = localStorage.getItem(noteKey) || '';
    right.innerHTML = `
      <div class="meta">
        <div class="idx">ÏƒÎ·Î¼ÎµÎ¯Ï‰ÏƒÎ· Î³Î¹Î± #${i+1}</div>
        <div class="tags"><span class="tag">autosave</span></div>
      </div>
      <textarea class="note" placeholder="Î³ÏÎ¬ÏˆÎµ ÎµÎ´Ïâ€¦">${escapeHtml(saved)}</textarea>
      <div class="noteFooter">
        <span class="len">0 chars</span>
        <span class="saved">â€”</span>
      </div>
    `;
    const ta = right.querySelector('textarea.note');
    const len = right.querySelector('.len');
    const savedEl = right.querySelector('.saved');

    const applyLen = () => {
      len.textContent = `${ta.value.length} chars`;
    };

    const applyLock = () => {
      if (!lockHeights) {
        ta.style.minHeight = '120px';
        return;
      }
      // match at least left ref height
      const leftRef = left.querySelector('.ref');
      const leftH = leftRef.getBoundingClientRect().height;
      const metaH = right.querySelector('.meta').getBoundingClientRect().height;
      const footerH = right.querySelector('.noteFooter').getBoundingClientRect().height;
      const target = Math.max(120, Math.ceil(leftH + 14)); // only content ref; decent
      ta.style.minHeight = `${target}px`;
      // Keep meta/footer visible and textarea not too short
      // (textarea height is independent; cards will expand)
    };

    const save = () => {
      localStorage.setItem(noteKey, ta.value);
      savedEl.textContent = `saved ${new Date().toLocaleTimeString('el-GR',{hour:'2-digit',minute:'2-digit'})}`;
      showToast(`saved #${i+1}`);
    };

    let t = null;
    ta.addEventListener('input', () => {
      applyLen();
      if (lockHeights) applyLock();
      clearTimeout(t);
      t = setTimeout(save, 250);
    });

    // first paint
    applyLen();
    requestAnimationFrame(() => applyLock());

    row.appendChild(left);
    row.appendChild(right);
    return row;
  };

  const render = () => {
    elRows.innerHTML = '';
    elGridHead.classList.remove('hidden');

    const frag = document.createDocumentFragment();
    blocks.forEach((b, i) => frag.appendChild(makeRow(i,b)));
    elRows.appendChild(frag);

    elStatus.textContent = `${blocks.length} blocks`;
    elRefInfo.textContent = `${blocks.length} blocks`;

    applyFilter();
  };

  const applyFilter = () => {
    const q = (elQ.value || '').trim().toLowerCase();
    const rows = [...elRows.querySelectorAll('.row')];
    if (!q) {
      rows.forEach(r => r.classList.remove('hidden'));
      return;
    }
    rows.forEach(r => {
      const i = Number(r.dataset.idx || '0');
      const b = blocks[i];
      const note = localStorage.getItem(`${sKey}:note:${i}`) || '';
      const hay = (b.plain + ' ' + note).toLowerCase();
      if (hay.includes(q)) r.classList.remove('hidden');
      else r.classList.add('hidden');
    });
  };

  elQ.addEventListener('input', applyFilter);

  btnToggleHeights.addEventListener('click', () => {
    lockHeights = !lockHeights;
    elLockState.textContent = lockHeights ? 'ON' : 'OFF';
    showToast(lockHeights ? 'lock heights ON' : 'lock heights OFF');

    // re-apply to all rows
    [...elRows.querySelectorAll('.row')].forEach(row => {
      const left = row.children[0];
      const right = row.children[1];
      const ta = right.querySelector('textarea.note');
      if (!ta) return;
      if (!lockHeights) {
        ta.style.minHeight = '120px';
        return;
      }
      const leftRef = left.querySelector('.ref');
      const leftH = leftRef.getBoundingClientRect().height;
      const target = Math.max(120, Math.ceil(leftH + 14));
      ta.style.minHeight = `${target}px`;
    });
  });

  const download = (filename, blob) => {
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    setTimeout(() => { URL.revokeObjectURL(a.href); a.remove(); }, 1000);
  };

  btnExportJson.addEventListener('click', () => {
    if (!sKey || !blocks.length) return showToast('Ï„Î¯Ï€Î¿Ï„Î± Î³Î¹Î± export');
    const notes = {};
    for (let i=0;i<blocks.length;i++){
      const v = localStorage.getItem(`${sKey}:note:${i}`) || '';
      if (v.trim().length) notes[i] = v;
    }
    const payload = {
      v: 1,
      sourceKey: sKey,
      exportedAt: new Date().toISOString(),
      blocks: blocks.length,
      notes
    };
    download('notes.json', new Blob([JSON.stringify(payload, null, 2)], {type:'application/json'}));
    showToast('export JSON ok');
  });

  elImportJson.addEventListener('change', async (e) => {
    const f = e.target.files && e.target.files[0];
    if (!f) return;
    try {
      const txt = await f.text();
      const data = JSON.parse(txt);
      if (!data || typeof data !== 'object' || !data.notes) throw new Error('bad json');
      if (!sKey || !blocks.length) throw new Error('Ï†ÏŒÏÏ„Ï‰ÏƒÎµ Ï€ÏÏÏ„Î± Î±Î½Î±Ï†Î¿ÏÎ¬');
      // Accept even if sourceKey differs (user may want restore anyway)
      const notes = data.notes || {};
      Object.keys(notes).forEach(k => {
        const idx = Number(k);
        if (!Number.isFinite(idx) || idx < 0 || idx >= blocks.length) return;
        localStorage.setItem(`${sKey}:note:${idx}`, String(notes[k] ?? ''));
      });
      render();
      showToast('import ok');
    } catch {
      showToast('import failed');
    } finally {
      e.target.value = '';
    }
  });

  btnExportHtml.addEventListener('click', () => {
    if (!sKey || !blocks.length) return showToast('Ï„Î¯Ï€Î¿Ï„Î± Î³Î¹Î± export');
    const rows = [];
    for (let i=0;i<blocks.length;i++){
      const note = localStorage.getItem(`${sKey}:note:${i}`) || '';
      rows.push({
        i,
        type: blocks[i].type,
        html: blocks[i].html,
        note
      });
    }

    const out = `<!doctype html>
<html lang="el">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Export â€” Î‘Î½Î±Ï†Î¿ÏÎ¬ + Î£Î·Î¼ÎµÎ¹ÏÏƒÎµÎ¹Ï‚</title>
<style>
  body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;background:#0b1220;color:#e8eefc}
  .wrap{max-width:1400px;margin:0 auto;padding:16px 14px 24px}
  .head{position:sticky;top:0;background:rgba(11,18,32,.92);backdrop-filter:blur(10px);border-bottom:1px solid rgba(255,255,255,.08);padding:12px 14px}
  .head .k{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;color:#9fb2e8;font-size:12px}
  .row{display:grid;grid-template-columns:1fr 1fr;gap:12px;align-items:start;margin-top:12px}
  .card{border-radius:18px;border:1px solid rgba(255,255,255,.08);background:rgba(15,26,51,.45);overflow:hidden}
  .meta{display:flex;justify-content:space-between;align-items:center;padding:10px 12px;border-bottom:1px solid rgba(255,255,255,.08);background:rgba(12,21,43,.55)}
  .idx{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;font-size:12px;color:#9fb2e8}
  .ref{padding:12px 14px 14px;line-height:1.45;overflow-wrap:anywhere}
  .ref img{max-width:100%;height:auto;border-radius:12px;border:1px solid rgba(255,255,255,.08)}
  .ref a{color:#7aa2ff}
  .note{white-space:pre-wrap;padding:12px 14px 14px;line-height:1.5}
  @media (max-width: 980px){.row{grid-template-columns:1fr}}
</style>
</head>
<body>
  <div class="head">
    <div style="font-weight:800">Export â€” Î‘Î½Î±Ï†Î¿ÏÎ¬ + Î£Î·Î¼ÎµÎ¹ÏÏƒÎµÎ¹Ï‚</div>
    <div class="k">sourceKey: ${escapeHtml(sKey)} Â· blocks: ${rows.length} Â· exportedAt: ${new Date().toISOString()}</div>
  </div>
  <div class="wrap">
    ${rows.map(r => `
      <div class="row">
        <div class="card">
          <div class="meta"><div class="idx">#${r.i+1}</div><div class="idx">${escapeHtml(r.type)}</div></div>
          <div class="ref">${r.html}</div>
        </div>
        <div class="card">
          <div class="meta"><div class="idx">ÏƒÎ·Î¼ÎµÎ¯Ï‰ÏƒÎ·</div><div class="idx">#${r.i+1}</div></div>
          <div class="note">${escapeHtml(r.note || '')}</div>
        </div>
      </div>
    `).join('')}
  </div>
</body>
</html>`;

    download('export_reference_notes.html', new Blob([out], {type:'text/html;charset=utf-8'}));
    showToast('export HTML ok');
  });

  const buildAssetMapFromFolderUpload = (files) => {
    assetMap.clear();
    assetMapReverse.clear();
    for (const f of files) {
      const rel = normalizePath(f.webkitRelativePath || f.name);
      const url = URL.createObjectURL(f);
      assetMap.set(rel, url);
      assetMapReverse.set(url, f);

      // Also map just the basename if unique (helps if html uses only filename)
      // But avoid collisions.
    }

    // Add basename mapping when unique
    const baseCount = new Map();
    for (const rel of assetMap.keys()){
      const base = rel.split('/').pop();
      baseCount.set(base, (baseCount.get(base) || 0) + 1);
    }
    for (const [rel, url] of assetMap.entries()){
      const base = rel.split('/').pop();
      if ((baseCount.get(base) || 0) === 1) assetMap.set(base, url);
    }
  };

  const loadHtmlFile = async (files, htmlFile) => {
    const txt = await htmlFile.text();
    const rootPrefix = (htmlFile.webkitRelativePath || '').split('/').slice(0,-1).join('/');
    const fullHtmlKey = await sha256(txt);
    sKey = `refnotes:${fullHtmlKey.slice(0, 24)}`;

    const parser = new DOMParser();
    const doc = parser.parseFromString(txt, 'text/html');
    safeClean(doc);

    // Rewrite assets to blob URLs (images/css/etc)
    await rewriteDomAssets(doc, rootPrefix ? (rootPrefix + '/') : '');

    // Aggregate styles into head? We keep existing (now rewritten) links/styles.
    // Then we extract blocks from body/main.
    const container = bestBody(doc);
    blocks = flattenToBlocks(container);

    // Light scrub of each block: parse fragment and remove scripts just in case
    blocks = blocks.map(b => {
      const tmp = parser.parseFromString(`<div id="x">${b.html}</div>`, 'text/html');
      safeClean(tmp);
      const node = tmp.querySelector('#x');
      const cleaned = node ? node.innerHTML : b.html;
      return { ...b, html: cleaned };
    });

    // Attach global styles from the source into OUR document so blocks look similar
    injectSourceStyles(doc);

    elStatus.textContent = `loaded: ${htmlFile.name} (${bytesToNice(htmlFile.size)}) Â· ${blocks.length} blocks`;
    elPick.classList.add('hidden');
    elGridHead.classList.remove('hidden');

    render();
    showToast('loaded');
  };

  const injectSourceStyles = (doc) => {
    // Remove previous injected styles
    document.querySelectorAll('[data-srcstyle="1"]').forEach(n => n.remove());

    // Pull <style> and <link rel=stylesheet> from parsed doc
    const head = doc.head;
    if (!head) return;

    const links = [...head.querySelectorAll('link[rel="stylesheet"][href]')];
    const styles = [...head.querySelectorAll('style')];

    // Attach to our document head
    links.forEach(l => {
      const href = l.getAttribute('href');
      if (!href) return;
      const nl = document.createElement('link');
      nl.rel = 'stylesheet';
      nl.href = href;
      nl.setAttribute('data-srcstyle','1');
      document.head.appendChild(nl);
    });

    styles.forEach(s => {
      const ns = document.createElement('style');
      ns.textContent = s.textContent || '';
      ns.setAttribute('data-srcstyle','1');
      document.head.appendChild(ns);
    });
  };

  elFolder.addEventListener('change', async (e) => {
    const files = [...(e.target.files || [])];
    if (!files.length) return;

    buildAssetMapFromFolderUpload(files);

    const htmlFiles = pickHtmlCandidates(files);
    if (!htmlFiles.length) {
      elStatus.textContent = 'Î´ÎµÎ½ Î²ÏÎ­Î¸Î·ÎºÎµ .html ÏƒÏ„Î¿Î½ Ï†Î¬ÎºÎµÎ»Î¿';
      showToast('no html');
      return;
    }

    // If multiple, show picker
    if (htmlFiles.length > 1) {
      elPick.innerHTML = '';
      htmlFiles.slice(0, 25).forEach((f, idx) => {
        const opt = document.createElement('option');
        opt.value = String(idx);
        opt.textContent = `${f.name} Â· ${bytesToNice(f.size)} Â· ${f.webkitRelativePath || ''}`;
        elPick.appendChild(opt);
      });
      elPick.classList.remove('hidden');
      elStatus.textContent = `${htmlFiles.length} html files â€” Î´Î¹Î¬Î»ÎµÎ¾Îµ Î±Ï€ÏŒ Ï„Î¿ dropdown`;
      elGridHead.classList.add('hidden');
      elRows.innerHTML = '';
      blocks = [];
      sKey = null;

      // auto load first (largest) for convenience
      await loadHtmlFile(files, htmlFiles[0]);

      elPick.onchange = async () => {
        const idx = Number(elPick.value);
        const f = htmlFiles[idx] || htmlFiles[0];
        await loadHtmlFile(files, f);
      };

    } else {
      await loadHtmlFile(files, htmlFiles[0]);
    }

    // reset file input to allow re-upload same folder later
    e.target.value = '';
  });

})();
</script>
</body>
</html>
